<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/tim-kos/node-retry"

    >retry (v0.10.1)</a>
</h1>
<h4>Abstraction for exponential and custom retry strategies for failed operations.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.retry">module retry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.createTimeout">
            function <span class="apidocSignatureSpan">retry.</span>createTimeout
            <span class="apidocSignatureSpan">(attempt, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.operation">
            function <span class="apidocSignatureSpan">retry.</span>operation
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation">
            function <span class="apidocSignatureSpan">retry.</span>retry_operation
            <span class="apidocSignatureSpan">(timeouts, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.timeouts">
            function <span class="apidocSignatureSpan">retry.</span>timeouts
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.wrap">
            function <span class="apidocSignatureSpan">retry.</span>wrap
            <span class="apidocSignatureSpan">(obj, options, methods)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>retry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">retry.</span>retry_operation.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.retry.retry">module retry.retry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry.createTimeout">
            function <span class="apidocSignatureSpan">retry.retry.</span>createTimeout
            <span class="apidocSignatureSpan">(attempt, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry.operation">
            function <span class="apidocSignatureSpan">retry.retry.</span>operation
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry.timeouts">
            function <span class="apidocSignatureSpan">retry.retry.</span>timeouts
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry.wrap">
            function <span class="apidocSignatureSpan">retry.retry.</span>wrap
            <span class="apidocSignatureSpan">(obj, options, methods)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.retry.retry_operation">module retry.retry_operation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation.retry_operation">
            function <span class="apidocSignatureSpan">retry.</span>retry_operation
            <span class="apidocSignatureSpan">(timeouts, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.retry.retry_operation.prototype">module retry.retry_operation.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation.prototype.attempt">
            function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>attempt
            <span class="apidocSignatureSpan">(fn, timeoutOps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation.prototype.attempts">
            function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>attempts
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation.prototype.errors">
            function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>errors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation.prototype.mainError">
            function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>mainError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation.prototype.retry">
            function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>retry
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation.prototype.start">
            function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>start
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation.prototype.stop">
            function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.retry.retry_operation.prototype.try">
            function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>try
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.retry" id="apidoc.module.retry">module retry</a></h1>


    <h2>
        <a href="#apidoc.element.retry.createTimeout" id="apidoc.element.retry.createTimeout">
        function <span class="apidocSignatureSpan">retry.</span>createTimeout
        <span class="apidocSignatureSpan">(attempt, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTimeout = function (attempt, opts) {
  var random = (opts.randomize)
    ? (Math.random() + 1)
    : 1;

  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
  timeout = Math.min(timeout, opts.maxTimeout);

  return timeout;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To make this a little easier for you, use wolfram alpha to do the calculations:

&#x3c;http://www.wolframalpha.com/input/?i=Sum%5B1000*x^k%2C+{k%2C+0%2C+9}%5D+%3D+5+*+60+*+1000&#x3e;

[article]: http://dthain.blogspot.com/2009/02/exponential-backoff-in-distributed.html

### retry.<span class="apidocCodeKeywordSpan">createTimeout</span>(attempt, opts)

Returns a new `timeout` (integer in milliseconds) based on the given parameters.

`attempt` is an integer representing for which retry the timeout should be calculated. If your retry operation was executed 4 times
 you had one attempt and 3 retries. If you then want to calculate a new timeout, you should set `attempt` to 4 (attempts are zero
-indexed).

`opts` can include `factor`, `minTimeout`, `randomize` (boolean) and `maxTimeout`. They are documented above.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.operation" id="apidoc.element.retry.operation">
        function <span class="apidocSignatureSpan">retry.</span>operation
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">operation = function (options) {
  var timeouts = exports.timeouts(options);
  return new RetryOperation(timeouts, {
      forever: options &#x26;&#x26; options.forever,
      unref: options &#x26;&#x26; options.unref
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
means the last attempt is made after `17 minutes and 3 seconds`.

``` javascript
var dns = require(&#x27;dns&#x27;);
var retry = require(&#x27;retry&#x27;);

function faultTolerantResolve(address, cb) {
var operation = retry.<span class="apidocCodeKeywordSpan">operation</span>();

operation.attempt(function(currentAttempt) {
  dns.resolve(address, function(err, addresses) {
    if (operation.retry(err)) {
      return;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry_operation" id="apidoc.element.retry.retry_operation">
        function <span class="apidocSignatureSpan">retry.</span>retry_operation
        <span class="apidocSignatureSpan">(timeouts, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RetryOperation(timeouts, options) {
  // Compatibility for the old (timeouts, retryForever) signature
  if (typeof options === &#x27;boolean&#x27;) {
    options = { forever: options };
  }

  this._timeouts = timeouts;
  this._options = options || {};
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;

  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.timeouts" id="apidoc.element.retry.timeouts">
        function <span class="apidocSignatureSpan">retry.</span>timeouts
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeouts = function (options) {
  if (options instanceof Array) {
    return [].concat(options);
  }

  var opts = {
    retries: 10,
    factor: 2,
    minTimeout: 1 * 1000,
    maxTimeout: Infinity,
    randomize: false
  };
  for (var key in options) {
    opts[key] = options[key];
  }

  if (opts.minTimeout &#x3e; opts.maxTimeout) {
    throw new Error(&#x27;minTimeout is greater than maxTimeout&#x27;);
  }

  var timeouts = [];
  for (var i = 0; i &#x3c; opts.retries; i++) {
    timeouts.push(this.createTimeout(i, opts));
  }

  if (options &#x26;&#x26; options.forever &#x26;&#x26; !timeouts.length) {
    timeouts.push(this.createTimeout(i, opts));
  }

  // sort the array numerically ascending
  timeouts.sort(function(a,b) {
    return a - b;
  });

  return timeouts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

## API

### retry.operation([options])

Creates a new `RetryOperation` object. `options` is the same as `retry.<span class="apidocCodeKeywordSpan">timeouts</span>()`&#x27
;s `options`, with two additions:

* `forever`: Whether to retry forever, defaults to `false`.
* `unref`: Wether to [unref](https://nodejs.org/api/timers.html#timers_unref) the setTimeout&#x27;s, defaults to `false`.

### retry.timeouts([options])

Returns an array of timeouts. All time `options` and return values are in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.wrap" id="apidoc.element.retry.wrap">
        function <span class="apidocSignatureSpan">retry.</span>wrap
        <span class="apidocSignatureSpan">(obj, options, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (obj, options, methods) {
  if (options instanceof Array) {
    methods = options;
    options = null;
  }

  if (!methods) {
    methods = [];
    for (var key in obj) {
      if (typeof obj[key] === &#x27;function&#x27;) {
        methods.push(key);
      }
    }
  }

  for (var i = 0; i &#x3c; methods.length; i++) {
    var method   = methods[i];
    var original = obj[method];

    obj[method] = function retryWrapper() {
      var op       = exports.operation(options);
      var args     = Array.prototype.slice.call(arguments);
      var callback = args.pop();

      args.push(function(err) {
        if (op.retry(err)) {
          return;
        }
        if (err) {
          arguments[0] = op.mainError();
        }
        callback.apply(this, arguments);
      });

      op.attempt(function() {
        original.apply(obj, args);
      });
    };
    obj[method].options = options;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

`attempt` is an integer representing for which retry the timeout should be calculated. If your retry operation was executed 4 times
 you had one attempt and 3 retries. If you then want to calculate a new timeout, you should set `attempt` to 4 (attempts are zero
-indexed).

`opts` can include `factor`, `minTimeout`, `randomize` (boolean) and `maxTimeout`. They are documented above.

`retry.createTimeout()` is used internally by `retry.timeouts()` and is public for you to be able to create your own timeouts for
 reinserting an item, see [issue #13](https://github.com/tim-kos/node-retry/issues/13).

### retry.<span class="apidocCodeKeywordSpan">wrap</span>(obj, [options], [methodNames])

Wrap all functions of the `obj` with retry. Optionally you can pass operation options and
an array of method names which need to be wrapped.

```
retry.wrap(obj)
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.retry.retry" id="apidoc.module.retry.retry">module retry.retry</a></h1>


    <h2>
        <a href="#apidoc.element.retry.retry.createTimeout" id="apidoc.element.retry.retry.createTimeout">
        function <span class="apidocSignatureSpan">retry.retry.</span>createTimeout
        <span class="apidocSignatureSpan">(attempt, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTimeout = function (attempt, opts) {
  var random = (opts.randomize)
    ? (Math.random() + 1)
    : 1;

  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
  timeout = Math.min(timeout, opts.maxTimeout);

  return timeout;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To make this a little easier for you, use wolfram alpha to do the calculations:

&#x3c;http://www.wolframalpha.com/input/?i=Sum%5B1000*x^k%2C+{k%2C+0%2C+9}%5D+%3D+5+*+60+*+1000&#x3e;

[article]: http://dthain.blogspot.com/2009/02/exponential-backoff-in-distributed.html

### retry.<span class="apidocCodeKeywordSpan">createTimeout</span>(attempt, opts)

Returns a new `timeout` (integer in milliseconds) based on the given parameters.

`attempt` is an integer representing for which retry the timeout should be calculated. If your retry operation was executed 4 times
 you had one attempt and 3 retries. If you then want to calculate a new timeout, you should set `attempt` to 4 (attempts are zero
-indexed).

`opts` can include `factor`, `minTimeout`, `randomize` (boolean) and `maxTimeout`. They are documented above.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry.operation" id="apidoc.element.retry.retry.operation">
        function <span class="apidocSignatureSpan">retry.retry.</span>operation
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">operation = function (options) {
  var timeouts = exports.timeouts(options);
  return new RetryOperation(timeouts, {
      forever: options &#x26;&#x26; options.forever,
      unref: options &#x26;&#x26; options.unref
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
means the last attempt is made after `17 minutes and 3 seconds`.

``` javascript
var dns = require(&#x27;dns&#x27;);
var retry = require(&#x27;retry&#x27;);

function faultTolerantResolve(address, cb) {
var operation = retry.<span class="apidocCodeKeywordSpan">operation</span>();

operation.attempt(function(currentAttempt) {
  dns.resolve(address, function(err, addresses) {
    if (operation.retry(err)) {
      return;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry.timeouts" id="apidoc.element.retry.retry.timeouts">
        function <span class="apidocSignatureSpan">retry.retry.</span>timeouts
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeouts = function (options) {
  if (options instanceof Array) {
    return [].concat(options);
  }

  var opts = {
    retries: 10,
    factor: 2,
    minTimeout: 1 * 1000,
    maxTimeout: Infinity,
    randomize: false
  };
  for (var key in options) {
    opts[key] = options[key];
  }

  if (opts.minTimeout &#x3e; opts.maxTimeout) {
    throw new Error(&#x27;minTimeout is greater than maxTimeout&#x27;);
  }

  var timeouts = [];
  for (var i = 0; i &#x3c; opts.retries; i++) {
    timeouts.push(this.createTimeout(i, opts));
  }

  if (options &#x26;&#x26; options.forever &#x26;&#x26; !timeouts.length) {
    timeouts.push(this.createTimeout(i, opts));
  }

  // sort the array numerically ascending
  timeouts.sort(function(a,b) {
    return a - b;
  });

  return timeouts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

## API

### retry.operation([options])

Creates a new `RetryOperation` object. `options` is the same as `retry.<span class="apidocCodeKeywordSpan">timeouts</span>()`&#x27
;s `options`, with two additions:

* `forever`: Whether to retry forever, defaults to `false`.
* `unref`: Wether to [unref](https://nodejs.org/api/timers.html#timers_unref) the setTimeout&#x27;s, defaults to `false`.

### retry.timeouts([options])

Returns an array of timeouts. All time `options` and return values are in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry.wrap" id="apidoc.element.retry.retry.wrap">
        function <span class="apidocSignatureSpan">retry.retry.</span>wrap
        <span class="apidocSignatureSpan">(obj, options, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (obj, options, methods) {
  if (options instanceof Array) {
    methods = options;
    options = null;
  }

  if (!methods) {
    methods = [];
    for (var key in obj) {
      if (typeof obj[key] === &#x27;function&#x27;) {
        methods.push(key);
      }
    }
  }

  for (var i = 0; i &#x3c; methods.length; i++) {
    var method   = methods[i];
    var original = obj[method];

    obj[method] = function retryWrapper() {
      var op       = exports.operation(options);
      var args     = Array.prototype.slice.call(arguments);
      var callback = args.pop();

      args.push(function(err) {
        if (op.retry(err)) {
          return;
        }
        if (err) {
          arguments[0] = op.mainError();
        }
        callback.apply(this, arguments);
      });

      op.attempt(function() {
        original.apply(obj, args);
      });
    };
    obj[method].options = options;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

`attempt` is an integer representing for which retry the timeout should be calculated. If your retry operation was executed 4 times
 you had one attempt and 3 retries. If you then want to calculate a new timeout, you should set `attempt` to 4 (attempts are zero
-indexed).

`opts` can include `factor`, `minTimeout`, `randomize` (boolean) and `maxTimeout`. They are documented above.

`retry.createTimeout()` is used internally by `retry.timeouts()` and is public for you to be able to create your own timeouts for
 reinserting an item, see [issue #13](https://github.com/tim-kos/node-retry/issues/13).

### retry.<span class="apidocCodeKeywordSpan">wrap</span>(obj, [options], [methodNames])

Wrap all functions of the `obj` with retry. Optionally you can pass operation options and
an array of method names which need to be wrapped.

```
retry.wrap(obj)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.retry.retry_operation" id="apidoc.module.retry.retry_operation">module retry.retry_operation</a></h1>


    <h2>
        <a href="#apidoc.element.retry.retry_operation.retry_operation" id="apidoc.element.retry.retry_operation.retry_operation">
        function <span class="apidocSignatureSpan">retry.</span>retry_operation
        <span class="apidocSignatureSpan">(timeouts, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RetryOperation(timeouts, options) {
  // Compatibility for the old (timeouts, retryForever) signature
  if (typeof options === &#x27;boolean&#x27;) {
    options = { forever: options };
  }

  this._timeouts = timeouts;
  this._options = options || {};
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;

  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.retry.retry_operation.prototype" id="apidoc.module.retry.retry_operation.prototype">module retry.retry_operation.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.retry.retry_operation.prototype.attempt" id="apidoc.element.retry.retry_operation.prototype.attempt">
        function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>attempt
        <span class="apidocSignatureSpan">(fn, timeoutOps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attempt = function (fn, timeoutOps) {
  this._fn = fn;

  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }

  var self = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self._operationTimeoutCb();
    }, self._operationTimeout);
  }

  this._fn(this._attempts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` javascript
var dns = require(&#x27;dns&#x27;);
var retry = require(&#x27;retry&#x27;);

function faultTolerantResolve(address, cb) {
  var operation = retry.operation();

  operation.<span class="apidocCodeKeywordSpan">attempt</span>(function(currentAttempt) {
dns.resolve(address, function(err, addresses) {
  if (operation.retry(err)) {
    return;
  }

  cb(err ? operation.mainError() : null, addresses);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry_operation.prototype.attempts" id="apidoc.element.retry.retry_operation.prototype.attempts">
        function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>attempts
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attempts = function () {
  return this._attempts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Otherwise it returns `true`, and retries the operation after the timeout for
the current attempt number.

#### retryOperation.stop()

Allows you to stop the operation being retried. Useful for aborting the operation on a fatal error etc.

#### retryOperation.<span class="apidocCodeKeywordSpan">attempts</span>()

Returns an int representing the number of attempts it took to call `fn` before it was successful.

## License

retry is licensed under the MIT license.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry_operation.prototype.errors" id="apidoc.element.retry.retry_operation.prototype.errors">
        function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>errors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors = function () {
  return this._errors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a timeout given in milliseconds.

Available options:
* `forever`: Whether to retry forever, defaults to `false`.
* `unref`: Wether to [unref](https://nodejs.org/api/timers.html#timers_unref) the setTimeout&#x27;s, defaults to `false`.

If `forever` is true, the following changes happen:
* `RetryOperation.<span class="apidocCodeKeywordSpan">errors</span>()` will only output an array of one item: the last error.
* `RetryOperation` will repeatedly use the `timeouts` array. Once all of its timeouts have been used up, it restarts with the first
 timeout, then uses the second and so on.

#### retryOperation.errors()

Returns an array of all errors that have been passed to
`retryOperation.retry()` so far.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry_operation.prototype.mainError" id="apidoc.element.retry.retry_operation.prototype.mainError">
        function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>mainError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mainError = function () {
  if (this._errors.length === 0) {
    return null;
  }

  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;

  for (var i = 0; i &#x3c; this._errors.length; i++) {
    var error = this._errors[i];
    var message = error.message;
    var count = (counts[message] || 0) + 1;

    counts[message] = count;

    if (count &#x3e;= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }

  return mainError;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  operation.attempt(function(currentAttempt) {
    dns.resolve(address, function(err, addresses) {
      if (operation.retry(err)) {
        return;
      }

      cb(err ? operation.<span class="apidocCodeKeywordSpan">mainError</span>() : null, addresses);
    });
  });
}

faultTolerantResolve(&#x27;nodejs.org&#x27;, function(err, addresses) {
  console.log(err, addresses);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry_operation.prototype.retry" id="apidoc.element.retry.retry_operation.prototype.retry">
        function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>retry
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retry = function (err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  if (!err) {
    return false;
  }

  this._errors.push(err);

  var timeout = this._timeouts.shift();
  if (timeout === undefined) {
    if (this._cachedTimeouts) {
      // retry forever, only keep last error
      this._errors.splice(this._errors.length - 1, this._errors.length);
      this._timeouts = this._cachedTimeouts.slice(0);
      timeout = this._timeouts.shift();
    } else {
      return false;
    }
  }

  var self = this;
  var timer = setTimeout(function() {
    self._attempts++;

    if (self._operationTimeoutCb) {
      self._timeout = setTimeout(function() {
        self._operationTimeoutCb(self._attempts);
      }, self._operationTimeout);

      if (this._options.unref) {
          self._timeout.unref();
      }
    }

    self._fn(self._attempts);
  }, timeout);

  if (this._options.unref) {
      timer.unref();
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var retry = require(&#x27;retry&#x27;);

function faultTolerantResolve(address, cb) {
  var operation = retry.operation();

  operation.attempt(function(currentAttempt) {
    dns.resolve(address, function(err, addresses) {
      if (operation.<span class="apidocCodeKeywordSpan">retry</span>(err)) {
        return;
      }

      cb(err ? operation.mainError() : null, addresses);
    });
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry_operation.prototype.start" id="apidoc.element.retry.retry_operation.prototype.start">
        function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>start
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (fn) {
  console.log(&#x27;Using RetryOperation.try() is deprecated&#x27;);
  this.attempt(fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Whenever your retry operation takes longer than `timeout` to execute, the timeout callback function `cb` is called.


#### retryOperation.try(fn)

This is an alias for `retryOperation.attempt(fn)`. This is deprecated. Please use `retryOperation.attempt(fn)` instead.

#### retryOperation.<span class="apidocCodeKeywordSpan">start</span>(fn)

This is an alias for `retryOperation.attempt(fn)`. This is deprecated. Please use `retryOperation.attempt(fn)` instead.

#### retryOperation.retry(error)

Returns `false` when no `error` value is given, or the maximum amount of retries
has been reached.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry_operation.prototype.stop" id="apidoc.element.retry.retry_operation.prototype.stop">
        function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function () {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  this._timeouts       = [];
  this._cachedTimeouts = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns `false` when no `error` value is given, or the maximum amount of retries
has been reached.

Otherwise it returns `true`, and retries the operation after the timeout for
the current attempt number.

#### retryOperation.<span class="apidocCodeKeywordSpan">stop</span>()

Allows you to stop the operation being retried. Useful for aborting the operation on a fatal error etc.

#### retryOperation.attempts()

Returns an int representing the number of attempts it took to call `fn` before it was successful.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.retry.retry_operation.prototype.try" id="apidoc.element.retry.retry_operation.prototype.try">
        function <span class="apidocSignatureSpan">retry.retry_operation.prototype.</span>try
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">try = function (fn) {
  console.log(&#x27;Using RetryOperation.try() is deprecated&#x27;);
  this.attempt(fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Defines the function `fn` that is to be retried and executes it for the first
time right away. The `fn` function can receive an optional `currentAttempt` callback that represents the number of attempts to execute
 `fn` so far.

Optionally defines `timeoutOps` which is an object having a property `timeout` in miliseconds and a property `cb` callback function
.
Whenever your retry operation takes longer than `timeout` to execute, the timeout callback function `cb` is called.


#### retryOperation.<span class="apidocCodeKeywordSpan">try</span>(fn)

This is an alias for `retryOperation.attempt(fn)`. This is deprecated. Please use `retryOperation.attempt(fn)` instead.

#### retryOperation.start(fn)

This is an alias for `retryOperation.attempt(fn)`. This is deprecated. Please use `retryOperation.attempt(fn)` instead.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
